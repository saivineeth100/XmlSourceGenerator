# Advanced Features

## Inheritance

The generator fully supports class inheritance with correct property ordering (base properties first).

```csharp
[XmlAutoGenerated]
public partial class BaseEntity
{
    public int Id { get; set; }
    public string Name { get; set; }
}

[XmlAutoGenerated]
public partial class DerivedEntity : BaseEntity
{
    public string Description { get; set; }
}
```

**XML Output** (note property order):
```xml
<DerivedEntity>
  <Id>1</Id>
  <Name>Base Property</Name>
  <Description>Derived Property</Description>
</DerivedEntity>
```

## Property Overriding

### Explicit Attribute Override

Override XML attributes in derived classes:

```csharp
[XmlAutoGenerated]
public partial class Base
{
    [XmlElement("BaseName")]
    public virtual string Name { get; set; }
}

[XmlAutoGenerated]
public partial class Derived : Base
{
    [XmlElement("DerivedName")]  // Overrides base attribute
    public override string Name { get; set; }
}
```

### Automatic Attribute Inheritance âœ¨ **New!**

When using `override` without XML attributes, the property **automatically inherits** attributes from the base property:

```csharp
[XmlAutoGenerated]
public partial class Base
{
    [XmlElement("CustomName")]
    [XmlAttribute("customId")]
    public virtual string Name { get; set; }
    public virtual int Id { get; set; }
}

[XmlAutoGenerated]
public partial class Derived : Base
{
    // Automatically inherits [XmlElement("CustomName")]
    public override string Name { get; set; }
    
    // Automatically inherits [XmlAttribute("customId")]
    public override int Id { get; set; }
}
```

**XML Output** (uses inherited attributes):
```xml
<Derived>
  <CustomName>John</CustomName>
  <customId>123</customId>
</Derived>
```

### Ignoring Inherited Properties

Use `[XmlIgnore]` to hide a base property:

```csharp
[XmlAutoGenerated]
public partial class Derived : Base
{
    [XmlIgnore]
    public override string Name { get; set; }
}
```

### Changing Serialization Mode

Convert between element and attribute serialization:

```csharp
[XmlAutoGenerated]
public partial class Base
{
    [XmlElement("Data")]
    public virtual string Data { get; set; }
}

[XmlAutoGenerated]
public partial class Derived : Base
{
    [XmlAttribute("data")]  // Now an attribute instead of element
    public override string Data { get; set; }
}
```

### Multi-Level Inheritance

Attribute inheritance works through multiple levels:

```csharp
[XmlAutoGenerated]
public partial class GrandParent
{
    [XmlElement("GrandParentName")]
    public virtual string Name { get; set; }
}

[XmlAutoGenerated]
public partial class Parent : GrandParent
{
    [XmlElement("ParentName")]  // Overrides GrandParent
    public override string Name { get; set; }
}

[XmlAutoGenerated]
public partial class Child : Parent
{
    // Inherits from immediate Parent: [XmlElement("ParentName")]
    public override string Name { get; set; }
}
```

### Collection Properties

Override collection serialization attributes:

```csharp
[XmlAutoGenerated]
public partial class Base
{
    [XmlArray("BaseItems")]
    [XmlArrayItem("BaseItem")]
    public virtual List<string> Items { get; set; }
}

[XmlAutoGenerated]
public partial class Derived : Base
{
    // Option 1: Override with new names
    [XmlArray("DerivedItems")]
    [XmlArrayItem("DerivedItem")]
    public override List<string> Items { get; set; }
    
    // Option 2: Omit attributes to inherit from base
    // public override List<string> Items { get; set; }
}
```

### Shadowing with `new` Keyword

Using `new` (instead of `override`) creates a completely independent property with no inheritance:

```csharp
[XmlAutoGenerated]
public partial class Base
{
    [XmlElement("BaseProp")]
    public virtual string Property { get; set; }
}

[XmlAutoGenerated]
public partial class Derived : Base
{
    // No attribute inheritance - needs explicit attributes or uses property name
    public new string Property { get; set; }
}
```


## Recursive Structures

Self-referencing types work correctly (e.g., tree structures):

```csharp
[XmlAutoGenerated]
public partial class TreeNode
{
    public string Name { get; set; }
    
    [XmlArray("Children")]
    [XmlArrayItem("Node")]
    public List<TreeNode> Children { get; set; }
}
```

**Usage:**
```csharp
var root = new TreeNode
{
    Name = "Root",
    Children = new List<TreeNode>
    {
        new TreeNode { Name = "Child1" },
        new TreeNode 
        { 
            Name = "Child2",
            Children = new List<TreeNode>
            {
                new TreeNode { Name = "GrandChild" }
            }
        }
    }
};
```

## Polymorphism

Map different XML elements to different types:

```csharp
public abstract class Shape { }

[XmlAutoGenerated]
public partial class Circle : Shape
{
    public double Radius { get; set; }
}

[XmlAutoGenerated]
public partial class Rectangle : Shape
{
    public double Width { get; set; }
    public double Height { get; set; }
}

[XmlAutoGenerated]
public partial class Drawing
{
    [XmlStreamListElement("Circle", typeof(Circle))]
    [XmlStreamListElement("Rectangle", typeof(Rectangle))]
    public List<Shape> Shapes { get; set; }
}
```

## Runtime Options

### Naming Policies

Change property naming conventions at runtime:

```csharp
var options = new XmlSerializationOptions
{
    PropertyNamingPolicy = XmlNamingPolicy.CamelCase
};

var xml = entity.WriteToXml(options);
```

**Available Policies:**
- `null` - Use original names (default)
- `XmlNamingPolicy.CamelCase` - `propertyName`
- `XmlNamingPolicy.SnakeCase` - `property_name`

### Property Overrides

Override element names at runtime:

```csharp
var options = new XmlSerializationOptions();
options.PropertyOverrides[(typeof(User), "Name")] = "FullName";

var xml = user.WriteToXml(options);
```

**Note:** Attribute-defined names take precedence over runtime overrides.

### Indentation

Format output with indentation:

```csharp
var options = new XmlSerializationOptions
{
    WriteIndented = true
};
```

## Complex Nested Objects

Deep nesting is fully supported:

```csharp
[XmlAutoGenerated]
public partial class Company
{
    public string Name { get; set; }
    public Department MainDepartment { get; set; }
}

[XmlAutoGenerated]
public partial class Department
{
    public string Name { get; set; }
    public List<Employee> Employees { get; set; }
}

[XmlAutoGenerated]
public partial class Employee
{
    public string Name { get; set; }
    public Address HomeAddress { get; set; }
}

[XmlAutoGenerated]
public partial class Address
{
    public string Street { get; set; }
    public string City { get; set; }
}
```

## Nullable Types

Nullable value types and reference types are handled correctly:

```csharp
[XmlAutoGenerated]
public partial class Entity
{
    public int? OptionalId { get; set; }      // Nullable value type
    public string? OptionalName { get; set; }  // Nullable reference type
}
```

**Behavior:**
- `null` values are omitted from XML
- Non-null values are serialized
- Missing elements deserialize as `null`

## Enums

Enums are serialized by name:

```csharp
public enum Status { Active, Inactive, Suspended }

[XmlAutoGenerated]
public partial class User
{
    public Status Status { get; set; }
}
```

**XML:**
```xml
<User>
  <Status>Active</Status>
</User>
```

## All Primitive Types

Fully supported types:
- `int`, `long`, `short`, `byte`
- `double`, `float`, `decimal`
- `bool`
- `string`
- `DateTime`, `DateTimeOffset`, `DateOnly`, `TimeOnly`, `TimeSpan`
- `Guid`
- Nullable versions of all above
