# API Reference

## Interfaces

### `IXmlStreamable`

Generated interface implemented by all classes marked with `[XmlAutoGenerated]`.

```csharp
public interface IXmlStreamable
{
    void ReadFromXml(XElement element, XmlSerializationOptions? options = null);
    XElement WriteToXml(XmlSerializationOptions? options = null);
}
```

#### Methods

**`WriteToXml(XmlSerializationOptions? options = null)`**

Serializes the object to an `XElement`.

- **Parameters:**
  - `options` (optional): Runtime serialization options
- **Returns:** `XElement` representing the serialized object

**`ReadFromXml(XElement element, XmlSerializationOptions? options = null)`**

Deserializes the object from an `XElement`.

- **Parameters:**
  - `element`: The XML element to deserialize from
  - `options` (optional): Runtime deserialization options
- **Returns:** void (modifies the current instance)

---

## Classes

### `XmlSerializationOptions`

Runtime configuration for serialization behavior.

```csharp
public class XmlSerializationOptions
{
    public XmlNamingPolicy? PropertyNamingPolicy { get; set; }
    public bool WriteIndented { get; set; }
    public Dictionary<(Type Type, string PropertyName), string> PropertyOverrides { get; }
    
    public string? GetXmlName(Type type, string propertyName);
}
```

#### Properties

**`PropertyNamingPolicy`**

Transforms property names during serialization (e.g., camelCase, snake_case).

**`WriteIndented`**

Formats output XML with indentation for readability.

**`PropertyOverrides`**

Maps `(Type, PropertyName)` to custom XML element names.

#### Methods

**`GetXmlName(Type type, string propertyName)`**

Gets the effective XML name for a property considering overrides and naming policy.

---

### `XmlNamingPolicy`

Abstract base class for property naming transformations.

```csharp
public abstract class XmlNamingPolicy
{
    public static XmlNamingPolicy CamelCase { get; }
    public static XmlNamingPolicy SnakeCase { get; }
    
    public abstract string ConvertName(string name);
}
```

#### Static Properties

**`CamelCase`**

Converts `PropertyName` → `propertyName`

**`SnakeCase`**

Converts `PropertyName` → `property_name`

---

## Utility Classes

### `GenericXmlStreamer`

Helper class for streaming XML to/from generic collections.

```csharp
public static class GenericXmlStreamer
{
    public static void StreamToXml<T>(IEnumerable<T> items, Stream stream, 
        XmlSerializationOptions? options = null) where T : IXmlStreamable;
    
    public static List<T> StreamFromXml<T>(Stream stream, string rootName, 
        string itemName, XmlSerializationOptions? options = null) 
        where T : IXmlStreamable, new();
}
```

#### Methods

**`StreamToXml<T>`**

Streams a collection to XML without loading all items in memory.

**`StreamFromXml<T>`**

Streams XML to a collection, processing one item at a time.

---

### `XmlStreamProcessor`

Low-level XML streaming utilities.

```csharp
public static class XmlStreamProcessor
{
    public static IEnumerable<XElement> StreamElements(Stream stream, string elementName);
    public static void WriteElements(Stream stream, string rootName, 
        IEnumerable<XElement> elements);
}
```

---

## Extension Methods

(If you add extension methods in the future, document them here)

---

## Code Generation

The source generator creates implementations at compile time. You can view the generated code:

**Visual Studio:**
1. Solution Explorer → Dependencies → Analyzers → XmlSourceGenerator
2. Expand to see generated files

**Generated File Pattern:**
```
{ClassName}_XmlGenerated.g.cs
```

**Example Generated Code:**
```csharp
partial class User : IXmlStreamable
{
    public void ReadFromXml(XElement element, XmlSerializationOptions options = null)
    {
        var elem_Id = element.Element("Id");
        if (elem_Id != null) { Id = (int)elem_Id; }
        
        var elem_Name = element.Element("Name");
        if (elem_Name != null) { Name = elem_Name.Value; }
    }

    public XElement WriteToXml(XmlSerializationOptions options = null)
    {
        var element = new XElement("User");
        element.Add(new XElement("Id", Id));
        if (Name != null) element.Add(new XElement("Name", Name));
        return element;
    }
}
```
