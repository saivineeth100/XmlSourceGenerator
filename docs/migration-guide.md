# Migration Guide: From XmlSerializer to XmlSourceGenerator

This guide will help you migrate your existing code from `System.Xml.Serialization.XmlSerializer` to **XmlSourceGenerator**, a modern, compile-time alternative with better performance and AOT compatibility.

## Why Migrate?

| Benefit | Description |
|---------|-------------|
| üöÄ **Performance** | No reflection overhead - all code generated at compile time |
| ‚úÖ **AOT Compatible** | Works with Native AOT and assembly trimming |
| üîç **Type Safety** | Compile-time errors instead of runtime exceptions |
| üìñ **Debuggable** | Generated code is visible and step-debuggable |
| üéØ **IntelliSense** | Full IDE support for generated methods |

> [!NOTE]
> XmlSourceGenerator currently supports **82% (23/28)** of XmlSerializer features. See the [feature comparison](xmlserializer-comparison.md) for details.

---

## Quick Migration Checklist

Use this checklist before migrating:

- [ ] Review [Feature Parity Matrix](xmlserializer-comparison.md#feature-parity-matrix) to ensure your features are supported
- [ ] Identify any unsupported features (`[XmlChoiceIdentifier]`, `ShouldSerialize`, `[DefaultValue]`)
- [ ] Plan workarounds for unsupported features
- [ ] Back up your existing code
- [ ] Migrate one class at a time
- [ ] Test each migration thoroughly

---

## Step-by-Step Migration

### Step 1: Install the Package

```bash
dotnet add package XmlSourceGenerator
```

### Step 2: Add Using Directives

**Before (XmlSerializer):**
```csharp
using System.Xml.Serialization;
```

**After (XmlSourceGenerator):**
```csharp
using System.Xml.Serialization;  // Keep this for attributes
using SourceGeneratorUtils;      // Add this for [XmlAutoGenerated]
```

> [!TIP]
> You can keep both usings during migration to support gradual transition.

### Step 3: Mark Classes for Generation

**Before (XmlSerializer):**
```csharp
public class User
{
    public int Id { get; set; }
    public string Name { get; set; }
}
```

**After (XmlSourceGenerator):**
```csharp
[XmlAutoGenerated]              // Add this attribute
public partial class User       // Add 'partial' keyword
{
    public int Id { get; set; }
    public string Name { get; set; }
}
```

> [!IMPORTANT]
> Two changes are **required**:
> 1. Add `[XmlAutoGenerated]` attribute
> 2. Make the class `partial`

### Step 4: Update Serialization Code

**Before (XmlSerializer):**
```csharp
// Serialization
var serializer = new XmlSerializer(typeof(User));
using (var writer = new StringWriter())
{
    serializer.Serialize(writer, user);
    string xml = writer.ToString();
}

// Deserialization
using (var reader = new StringReader(xmlString))
{
    var user = (User)serializer.Deserialize(reader);
}
```

**After (XmlSourceGenerator):**
```csharp
// Serialization
XElement xml = user.WriteToXml();
string xmlString = xml.ToString();

// Deserialization
var xml = XElement.Parse(xmlString);
var user = new User();
user.ReadFromXml(xml);
```

> [!TIP]
> The generated `WriteToXml()` and `ReadFromXml()` methods are extension methods added to your class.

---

## Feature-by-Feature Migration

### Basic Attributes ‚úÖ

All basic attributes work identically - no changes needed!

| Attribute | Migration Status | Notes |
|-----------|-----------------|-------|
| `[XmlRoot]` | ‚úÖ Drop-in replacement | Works identically |
| `[XmlElement]` | ‚úÖ Drop-in replacement | Works identically |
| `[XmlAttribute]` | ‚úÖ Drop-in replacement | Works identically |
| `[XmlIgnore]` | ‚úÖ Drop-in replacement | Works identically |
| `[XmlText]` | ‚úÖ Drop-in replacement | Works identically |
| `[XmlArray]` | ‚úÖ Drop-in replacement | Works identically |
| `[XmlArrayItem]` | ‚úÖ Drop-in replacement | Works identically |

**Example (same code works for both):**
```csharp
[XmlRoot("Person")]
[XmlAutoGenerated]  // Only addition needed
public partial class Person
{
    [XmlAttribute("id")]
    public int Id { get; set; }
    
    [XmlElement("FullName")]
    public string Name { get; set; }
    
    [XmlIgnore]
    public string Password { get; set; }
}
```

### DateTime Formatting ‚úÖ

**Before (XmlSerializer):**
```csharp
// Custom serialization required
public DateTime BirthDate { get; set; }

[XmlElement("BirthDateString")]
public string BirthDateString
{
    get => BirthDate.ToString("yyyy-MM-dd");
    set => BirthDate = DateTime.Parse(value);
}

[XmlIgnore]
public DateTime BirthDate { get; set; }
```

**After (XmlSourceGenerator):**
```csharp
// Direct attribute support
[XmlFormat("yyyy-MM-dd")]
public DateTime BirthDate { get; set; }
```

> [!TIP]
> `[XmlFormat]` supports multiple parse formats:
> ```csharp
> [XmlFormat("yyyy-MM-dd", "MM/dd/yyyy", "dd-MM-yyyy")]
> public DateTime FlexibleDate { get; set; }
> ```

### Collections ‚úÖ

**Wrapped Collections:**
```csharp
// Works identically in both
[XmlArray("Tags")]
[XmlArrayItem("Tag")]
public List<string> Tags { get; set; }
```

**Flat Collections (unwrapped):**
```csharp
// Works identically in both
[XmlElement("Tag")]
public List<string> Tags { get; set; }
```

### Inheritance ‚úÖ

**Before (XmlSerializer):**
```csharp
public class BaseEntity
{
    public int Id { get; set; }
}

public class DerivedEntity : BaseEntity
{
    public string Name { get; set; }
}
```

**After (XmlSourceGenerator):**
```csharp
[XmlAutoGenerated]
public partial class BaseEntity
{
    public int Id { get; set; }
}

[XmlAutoGenerated]
public partial class DerivedEntity : BaseEntity
{
    public string Name { get; set; }
}
```

> [!NOTE]
> Both classes need `[XmlAutoGenerated]` and `partial` keywords.

### Polymorphism ‚ö†Ô∏è Different Approach

**Before (XmlSerializer):**
```csharp
[XmlInclude(typeof(Dog))]
[XmlInclude(typeof(Cat))]
public class Animal
{
    public string Name { get; set; }
}

public class Container
{
    public List<Animal> Animals { get; set; }
}
```

**After (XmlSourceGenerator):**
```csharp
public abstract class Animal
{
    public string Name { get; set; }
}

[XmlAutoGenerated]
public partial class Dog : Animal
{
    public string Breed { get; set; }
}

[XmlAutoGenerated]
public partial class Cat : Animal
{
    public int Lives { get; set; }
}

[XmlAutoGenerated]
public partial class Container
{
    // Use XmlStreamListElement to map element names to types
    [XmlStreamListElement("Dog", typeof(Dog))]
    [XmlStreamListElement("Cat", typeof(Cat))]
    public List<Animal> Animals { get; set; }
}
```

> [!IMPORTANT]
> **Key Difference:** Use `[XmlStreamListElement]` on the **collection property**, not `[XmlInclude]` on the base class.

### XML Namespaces ‚úÖ

**Before (XmlSerializer):**
```csharp
[XmlRoot("Order", Namespace = "http://example.com/orders")]
public class Order
{
    [XmlElement("Item", Namespace = "http://example.com/items")]
    public string Item { get; set; }
}
```

**After (XmlSourceGenerator):**
```csharp
[XmlRoot("Order", Namespace = "http://example.com/orders")]
[XmlAutoGenerated]
public partial class Order
{
    [XmlElement("Item", Namespace = "http://example.com/items")]
    public string Item { get; set; }
}
```

> [!WARNING]
> Custom namespace **prefixes** are not supported. XNamespace is used with default prefixes.

---

## Handling Unsupported Features

### ‚ùå `[DefaultValue]` and Conditional Serialization

**Before (XmlSerializer):**
```csharp
public class Config
{
    [DefaultValue(100)]
    public int Timeout { get; set; } = 100;
    
    public bool ShouldSerializeTimeout()
    {
        return Timeout != 100;  // Only serialize if not default
    }
}
```

**Workaround:**
```csharp
[XmlAutoGenerated]
public partial class Config
{
    private int _timeout = 100;
    
    [XmlIgnore]
    public int Timeout
    {
        get => _timeout;
        set => _timeout = value;
    }
    
    // Serialize only when non-default
    [XmlElement("Timeout")]
    public int? SerializableTimeout
    {
        get => Timeout == 100 ? null : Timeout;
        set => Timeout = value ?? 100;
    }
}
```

> [!TIP]
> Use nullable properties to skip default values (nulls are not serialized).

### ‚ùå `XXXSpecified` Pattern

**Before (XmlSerializer):**
```csharp
public class Product
{
    public decimal Price { get; set; }
    public bool PriceSpecified { get; set; }  // Controls serialization
}
```

**Workaround:**
```csharp
[XmlAutoGenerated]
public partial class Product
{
    [XmlIgnore]
    public decimal Price { get; set; }
    
    public bool PriceSpecified { get; set; }
    
    [XmlElement("Price")]
    public decimal? SerializablePrice
    {
        get => PriceSpecified ? Price : null;
        set
        {
            if (value.HasValue)
            {
                Price = value.Value;
                PriceSpecified = true;
            }
        }
    }
}
```

### ‚ùå `[XmlChoiceIdentifier]`

**Before (XmlSerializer):**
```csharp
public class Message
{
    [XmlChoiceIdentifier("ItemType")]
    [XmlElement("Text", typeof(string))]
    [XmlElement("Number", typeof(int))]
    public object Item { get; set; }
    
    public ItemChoice ItemType { get; set; }
}

public enum ItemChoice { Text, Number }
```

**Workaround:**
```csharp
[XmlAutoGenerated]
public partial class Message
{
    [XmlElement("Text")]
    public string TextItem { get; set; }
    
    [XmlElement("Number")]
    public int? NumberItem { get; set; }
    
    [XmlIgnore]
    public object Item
    {
        get => TextItem ?? (object)NumberItem;
        set
        {
            if (value is string s)
                TextItem = s;
            else if (value is int i)
                NumberItem = i;
        }
    }
}
```

> [!CAUTION]
> Choice patterns require manual property splitting. Test thoroughly after migration.

---

## Testing Your Migration

### 1. **XML Compatibility Testing**

Ensure XML output is identical:

```csharp
// Test that both produce the same XML
var user = new User { Id = 1, Name = "Alice" };

// Old way
var serializer = new XmlSerializer(typeof(User));
using var writerOld = new StringWriter();
serializer.Serialize(writerOld, user);
string xmlOld = writerOld.ToString();

// New way
string xmlNew = user.WriteToXml().ToString();

// Compare (normalize whitespace first)
Assert.Equal(
    NormalizeXml(xmlOld), 
    NormalizeXml(xmlNew)
);

string NormalizeXml(string xml) => 
    XElement.Parse(xml).ToString(SaveOptions.DisableFormatting);
```

### 2. **Round-Trip Testing**

Verify serialization ‚Üí deserialization works:

```csharp
// Original object
var original = new User { Id = 1, Name = "Alice", Email = "alice@example.com" };

// Serialize
var xml = original.WriteToXml();

// Deserialize
var restored = new User();
restored.ReadFromXml(xml);

// Verify
Assert.Equal(original.Id, restored.Id);
Assert.Equal(original.Name, restored.Name);
Assert.Equal(original.Email, restored.Email);
```

### 3. **Edge Case Testing**

Test boundary conditions:

```csharp
// Null properties
var userNull = new User { Id = 1, Name = null };

// Empty collections
var userEmpty = new User { Tags = new List<string>() };

// Special characters
var userSpecial = new User { Name = "<>&\"'" };

// Large collections
var userLarge = new User { Tags = Enumerable.Range(1, 10000).Select(i => $"Tag{i}").ToList() };
```

---

## Performance Comparison

Benchmark your migration to see the improvements:

```csharp
using BenchmarkDotNet.Attributes;

[MemoryDiagnoser]
public class SerializationBenchmark
{
    private User _user;
    private XmlSerializer _serializer;
    
    [GlobalSetup]
    public void Setup()
    {
        _user = new User { Id = 1, Name = "Test" };
        _serializer = new XmlSerializer(typeof(User));
    }
    
    [Benchmark(Baseline = true)]
    public string XmlSerializer_Serialize()
    {
        using var writer = new StringWriter();
        _serializer.Serialize(writer, _user);
        return writer.ToString();
    }
    
    [Benchmark]
    public string SourceGenerator_Serialize()
    {
        return _user.WriteToXml().ToString();
    }
}
```

**Expected Results:**
- ‚ö° **2-5x faster** serialization
- üìâ **50-90% less** memory allocation
- üöÄ **Zero reflection** overhead

---

## Common Pitfalls

### ‚ùå Forgetting `partial` Keyword

**Error:** `XmlAutoGenerated attribute requires partial class`

**Fix:**
```csharp
// ‚ùå Wrong
[XmlAutoGenerated]
public class User { }

// ‚úÖ Correct
[XmlAutoGenerated]
public partial class User { }
```

### ‚ùå Missing Parameterless Constructor

**Error:** Generated code won't compile

**Fix:**
```csharp
[XmlAutoGenerated]
public partial class User
{
    public User() { }  // Add explicit constructor if you have others
    
    public User(int id, string name)
    {
        Id = id;
        Name = name;
    }
}
```

### ‚ùå Mixing XmlSerializer and SourceGenerator

**Issue:** Using `XmlSerializer` on `[XmlAutoGenerated]` classes

**Fix:**
```csharp
// ‚ùå Don't do this
var serializer = new XmlSerializer(typeof(User));
serializer.Serialize(writer, user);

// ‚úÖ Use generated methods
var xml = user.WriteToXml();
```

### ‚ùå Expecting Runtime Reflection

**Issue:** Trying to serialize types not marked with `[XmlAutoGenerated]`

**Fix:**
```csharp
// All types in the object graph need [XmlAutoGenerated]
[XmlAutoGenerated]
public partial class Order
{
    public Customer Customer { get; set; }  // Customer must also be annotated
}

[XmlAutoGenerated]  // Don't forget this!
public partial class Customer
{
    public string Name { get; set; }
}
```

---

## Migration Strategy

### For Small Projects (< 10 classes)

1. **Big Bang Approach:** Migrate all classes at once
2. Update all classes to use `[XmlAutoGenerated]` and `partial`
3. Update all serialization/deserialization code
4. Run full test suite
5. Deploy

### For Large Projects (> 10 classes)

1. **Gradual Migration:** One class or module at a time
2. Create adapter methods to support both during transition:

```csharp
public static class SerializationHelper
{
    public static string Serialize<T>(T obj)
    {
        // Check if type has source generator
        if (typeof(T).GetCustomAttribute<XmlAutoGeneratedAttribute>() != null)
        {
            var method = typeof(T).GetMethod("WriteToXml");
            var xml = (XElement)method.Invoke(obj, null);
            return xml.ToString();
        }
        
        // Fall back to XmlSerializer
        var serializer = new XmlSerializer(typeof(T));
        using var writer = new StringWriter();
        serializer.Serialize(writer, obj);
        return writer.ToString();
    }
}
```

3. Migrate and test one class at a time
4. Once all classes migrated, remove adapter
5. Remove XmlSerializer references

---

## Validation

After migration, verify:

- [ ] All tests passing
- [ ] XML output matches expected format
- [ ] Round-trip serialization works
- [ ] Edge cases handled (null, empty, special characters)
- [ ] Performance improvements measured
- [ ] No runtime exceptions
- [ ] Generated code compiles without warnings

---

## Getting Help

- üìñ [Full Documentation](getting-started.md)
- üè∑Ô∏è [Attributes Reference](attributes.md)
- üöÄ [Advanced Features](advanced-features.md)
- üìä [Feature Comparison](xmlserializer-comparison.md)
- üêõ [Report Issues](https://github.com/saivineeth/XmlSourceGenerator/issues)

---

## Next Steps

1. ‚úÖ Review the [Feature Comparison](xmlserializer-comparison.md) to ensure compatibility
2. ‚úÖ Try the [Quick Start](../README.md#quick-start) example
3. ‚úÖ Read the [Getting Started Guide](getting-started.md)
4. ‚úÖ Explore [Advanced Features](advanced-features.md) like inheritance and polymorphism
5. ‚úÖ Migrate one class and validate the XML output
6. ‚úÖ Gradually expand to your entire codebase

> [!TIP]
> Start with simple classes first to build confidence, then tackle complex scenarios.

**Happy migrating! üöÄ**
