using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SourceGeneratorUtils
{
    [Generator]
    public class XmlSourceGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (!(context.SyntaxReceiver is SyntaxReceiver receiver))
                return;

            var compilation = context.Compilation;
            var attributeSymbol = compilation.GetTypeByMetadataName("SourceGeneratorUtils.XmlAutoGeneratedAttribute");

            foreach (var classDeclaration in receiver.CandidateClasses)
            {
                var model = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
                var classSymbol = model.GetDeclaredSymbol(classDeclaration);

                if (classSymbol == null || !classSymbol.GetAttributes().Any(ad => SymbolEqualityComparer.Default.Equals(ad.AttributeClass, attributeSymbol)))
                    continue;

                string source = GenerateClass(classSymbol, compilation);
                context.AddSource($"{classSymbol.Name}_XmlGenerated.g.cs", SourceText.From(source, Encoding.UTF8));
            }
        }

        private string GenerateClass(INamedTypeSymbol classSymbol, Compilation compilation)
        {
            var sb = new IndentedStringBuilder();
            
            string namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
            
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using System.Xml.Linq;");
            sb.AppendLine("using System.Globalization;"); // For DateTime parsing
            sb.AppendLine("using SourceGeneratorUtils;");
            sb.AppendLine();
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
            
            using (sb.Indent())
            {
                var parents = new Stack<INamedTypeSymbol>();
                var current = classSymbol.ContainingType;
                while (current != null)
                {
                    parents.Push(current);
                    current = current.ContainingType;
                }

                foreach (var parent in parents)
                {
                    sb.AppendLine($"partial class {parent.Name}");
                    sb.AppendLine("{");
                    sb.Indent();
                }

                sb.AppendLine($"public partial class {classSymbol.Name} : IXmlStreamable");
                sb.AppendLine("{");
                
                using (sb.Indent())
                {
                    new XmlReadGenerator(sb, compilation).GenerateReadMethod(classSymbol);
                    sb.AppendLine();
                    new XmlWriteGenerator(sb, compilation).GenerateWriteMethod(classSymbol);
                }

                sb.AppendLine("}");

                foreach (var parent in parents)
                {
                    sb.DecrementIndent();
                    sb.AppendLine("}");
                }
            }
            sb.AppendLine("}");

            return sb.ToString();
        }

        class SyntaxReceiver : ISyntaxReceiver
        {
            public List<ClassDeclarationSyntax> CandidateClasses { get; } = new List<ClassDeclarationSyntax>();

            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                if (syntaxNode is ClassDeclarationSyntax classDeclaration &&
                    classDeclaration.AttributeLists.Count > 0)
                {
                    CandidateClasses.Add(classDeclaration);
                }
            }
        }
    }
}
