using System.Text;
using System.Linq;
using System.Collections.Generic;
using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using XmlSourceGenerator.Generators;
using XmlSourceGenerator.Helpers;

namespace XmlSourceGenerator
{
    [Generator]
    public class XmlGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Register a syntax provider to find classes with attributes
            var classDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                    transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
                .Where(static m => m is not null);

            // Combine with compilation to generate source
            var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

            context.RegisterSourceOutput(compilationAndClasses,
                static (spc, source) => Execute(source.Left, source.Right!, spc));
        }

        private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
        {
            return node is ClassDeclarationSyntax classDeclaration &&
                   classDeclaration.AttributeLists.Count > 0;
        }

        private static INamedTypeSymbol? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
        {
            var classDeclaration = (ClassDeclarationSyntax)context.Node;
            var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration);
            
            if (classSymbol == null)
                return null;

            // Check if the class has the XmlAutoGenerated attribute
            foreach (var attribute in classSymbol.GetAttributes())
            {
                if (attribute.AttributeClass?.ToDisplayString() == Constants.XmlAutoGeneratedAttributeFullName)
                {
                    return classSymbol;
                }
            }

            return null;
        }

        private static void Execute(Compilation compilation, ImmutableArray<INamedTypeSymbol?> classes, SourceProductionContext context)
        {
            if (classes.IsDefaultOrEmpty)
                return;

            foreach (var classSymbol in classes)
            {
                if (classSymbol == null)
                    continue;

                string source = GenerateClass(classSymbol, compilation);
                context.AddSource($"{classSymbol.Name}{Constants.GeneratedFileSuffix}", 
                    SourceText.From(source, Encoding.UTF8));
            }
        }

        private static string GenerateClass(INamedTypeSymbol classSymbol, Compilation compilation)
        {
            var sb = new IndentedStringBuilder();
            
            string namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
            
            sb.AppendLine($"using {Constants.SystemNamespace};");
            sb.AppendLine($"using {Constants.SystemCollectionsGenericNamespace};");
            sb.AppendLine($"using {Constants.SystemXmlLinqNamespace};");
            sb.AppendLine($"using {Constants.SystemGlobalizationNamespace};"); // For DateTime parsing
            sb.AppendLine($"using {Constants.AbstractionsNamespace};");
            sb.AppendLine();
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
            
            using (sb.Indent())
            {
                var parents = new Stack<INamedTypeSymbol>();
                var current = classSymbol.ContainingType;
                while (current != null)
                {
                    parents.Push(current);
                    current = current.ContainingType;
                }

                foreach (var parent in parents)
                {
                    sb.AppendLine($"partial class {parent.Name}");
                    sb.AppendLine("{");
                    sb.Indent();
                }

                sb.AppendLine($"public partial class {classSymbol.Name} : {Constants.IXmlStreamableInterfaceName}");
                sb.AppendLine("{");
                
                using (sb.Indent())
                {
                    // Generate nested XmlTypeInfo class
                    sb.AppendLine($"private static class {Constants.XmlTypeInfoClassName}");
                    sb.AppendLine("{");
                    using (sb.Indent())
                    {
                        sb.AppendLine($"public static readonly Type Type = typeof({classSymbol.ToDisplayString()});");
                        
                        var properties = PropertyHelpers.GetAllProperties(classSymbol);
                        var uniqueNamespaces = new System.Collections.Generic.HashSet<string>();
                        
                        // Check root namespace
                        string? rootNs = XmlNamespaceHelper.GetNamespace(classSymbol);
                        if (rootNs != null)
                        {
                            uniqueNamespaces.Add(rootNs);
                        }
                        
                        // Single loop: generate constants and collect namespaces
                        foreach (var prop in properties)
                        {
                            if (prop.IsStatic) continue;
                            
                            // Generate PropName constant
                            sb.AppendLine($"public const string {Constants.PropNamePrefix}{prop.Name} = nameof({classSymbol.ToDisplayString()}.{prop.Name});");
                            
                            // Generate DefaultXmlName constant
                            sb.AppendLine($"public const string {Constants.DefaultXmlNamePrefix}{prop.Name} = \"{prop.Name}\";");
                            
                            // Collect property namespace
                            string? propNs = XmlNamespaceHelper.GetNamespace(prop);
                            if (propNs != null)
                            {
                                uniqueNamespaces.Add(propNs);
                            }
                        }
                        
                        // Generate namespace fields
                        int nsIndex = 0;
                        var namespaceMap = new System.Collections.Generic.Dictionary<string, string>();
                        foreach (var ns in uniqueNamespaces)
                        {
                            string fieldName = $"{Constants.NamespaceFieldPrefix}{nsIndex}";
                            namespaceMap[ns] = fieldName;
                            sb.AppendLine($"public static readonly {Constants.XNamespaceTypeName} {fieldName} = {Constants.XNamespaceTypeName}.Get(\"{ns}\");");
                            nsIndex++;
                        }
                    }
                    sb.AppendLine("}");
                    sb.AppendLine();

                    new XmlReadGenerator(sb, compilation).GenerateReadMethod(classSymbol);
                    sb.AppendLine();
                    new XmlWriteGenerator(sb, compilation).GenerateWriteMethod(classSymbol);
                }

                sb.AppendLine("}");

                foreach (var parent in parents)
                {
                    sb.DecrementIndent();
                    sb.AppendLine("}");
                }
            }
            sb.AppendLine("}");

            return sb.ToString();
        }
    }
}
