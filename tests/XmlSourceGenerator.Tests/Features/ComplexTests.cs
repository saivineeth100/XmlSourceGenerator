using System;
using System.Collections.Generic;
using System.Xml.Linq;
using Xunit;
using SourceGeneratorUtils;

namespace SourceGeneratorUtils.Tests.Integration
{
    [XmlAutoGenerated]
    public partial class OverrideEntity
    {
        [XmlElement("CustomName")]
        public string OriginalName { get; set; }

        [XmlAttribute("id")]
        public int Identifier { get; set; }
    }

    [XmlAutoGenerated]
    public partial class RecursiveEntity
    {
        public string Name { get; set; }
        
        [XmlArray("Children")]
        [XmlArrayItem("Child")]
        public List<RecursiveEntity> Children { get; set; }
    }

    [XmlAutoGenerated]
    public partial class ComplexParent
    {
        public string ParentName { get; set; }
        public NestedChild Child { get; set; }
    }

    [XmlAutoGenerated]
    public partial class NestedChild
    {
        public string ChildName { get; set; }
        public DeeplyNested GrandChild { get; set; }
    }

    [XmlAutoGenerated]
    public partial class DeeplyNested
    {
        public int Value { get; set; }
    }

    [XmlAutoGenerated]
    public partial class BaseRecursive
    {
        public string BaseName { get; set; }
    }

    [XmlAutoGenerated]
    public partial class DerivedRecursive : BaseRecursive
    {
        public List<DerivedRecursive> Peers { get; set; }
    }

    public class ComplexTests
    {
        [Fact]
        public void TestOverriding()
        {
            // Test Attribute Overrides via Options vs Attributes
            // Attributes have precedence in current implementation unless logic changed?
            // Actually, generator logic: 
            // string xmlNameVar = options?.GetXmlName(...) ?? "PropName";
            // BUT if [XmlElement] is present, it uses that explicitly:
            // if (info.XmlElementName != null) sb.AppendLine($"string {xmlNameVar} = \"{info.XmlElementName}\";");
            // So [XmlElement] wins over Options. Let's verify.

            var options = new XmlSerializationOptions();
            options.PropertyOverrides[(typeof(OverrideEntity), "OriginalName")] = "OptionName";

            var entity = new OverrideEntity { OriginalName = "Test", Identifier = 1 };
            var xml = entity.WriteToXml(options);

            // Expectation: Attribute wins
            Assert.NotNull(xml.Element("CustomName"));
            Assert.Null(xml.Element("OptionName"));
            Assert.Null(xml.Element("OriginalName"));
            
            Assert.Equal("1", xml.Attribute("id")?.Value);
        }

        [Fact]
        public void TestRecursiveList()
        {
            var root = new RecursiveEntity
            {
                Name = "Root",
                Children = new List<RecursiveEntity>
                {
                    new RecursiveEntity 
                    { 
                        Name = "Level1_A",
                        Children = new List<RecursiveEntity>
                        {
                            new RecursiveEntity { Name = "Level2_A" }
                        }
                    },
                    new RecursiveEntity { Name = "Level1_B" }
                }
            };

            var xml = root.WriteToXml();

            Assert.Equal("Root", xml.Element("Name")?.Value);
            var children = xml.Element("Children");
            Assert.NotNull(children);
            Assert.Equal(2, children.Elements("Child").Count());
            
            var child1 = children.Elements("Child").First();
            Assert.Equal("Level1_A", child1.Element("Name")?.Value);
            
            var grandChildren = child1.Element("Children");
            Assert.NotNull(grandChildren);
            Assert.Single(grandChildren.Elements("Child"));
            Assert.Equal("Level2_A", grandChildren.Elements("Child").First().Element("Name")?.Value);

            // Round trip
            var restored = new RecursiveEntity();
            restored.ReadFromXml(xml);

            Assert.Equal("Root", restored.Name);
            Assert.Equal(2, restored.Children.Count);
            Assert.Equal("Level1_A", restored.Children[0].Name);
            Assert.Single(restored.Children[0].Children);
            Assert.Equal("Level2_A", restored.Children[0].Children[0].Name);
        }

        [Fact]
        public void TestComplexNesting()
        {
            var parent = new ComplexParent
            {
                ParentName = "Parent",
                Child = new NestedChild
                {
                    ChildName = "Junior",
                    GrandChild = new DeeplyNested { Value = 42 }
                }
            };

            var xml = parent.WriteToXml();

            Assert.Equal("Parent", xml.Element("ParentName")?.Value);
            Assert.NotNull(xml.Element("Child"));
            Assert.Equal("Junior", xml.Element("Child").Element("ChildName")?.Value);
            Assert.NotNull(xml.Element("Child").Element("GrandChild"));
            Assert.Equal("42", xml.Element("Child").Element("GrandChild").Element("Value")?.Value);

            // Round trip
            var restored = new ComplexParent();
            restored.ReadFromXml(xml);

            Assert.Equal("Parent", restored.ParentName);
            Assert.NotNull(restored.Child);
            Assert.Equal("Junior", restored.Child.ChildName);
            Assert.NotNull(restored.Child.GrandChild);
            Assert.Equal(42, restored.Child.GrandChild.Value);
        }

        [Fact]
        public void TestInheritanceRecursion()
        {
            var item = new DerivedRecursive
            {
                BaseName = "Base",
                Peers = new List<DerivedRecursive>
                {
                    new DerivedRecursive { BaseName = "Peer1" }
                }
            };

            var xml = item.WriteToXml();
            
            // Base property
            Assert.Equal("Base", xml.Element("BaseName")?.Value);
            
            // Recursive list
            var peers = xml.Element("Peers"); // Implicit container
            Assert.NotNull(peers);
            Assert.Single(peers.Elements("DerivedRecursive")); // Item name defaults to type name? Or implicit?
            // In GenerateCollectionWrite:
            // if (info.XmlElementName == null) -> var container = new XElement("Peers");
            // itemXmlName = itemType.Name -> "DerivedRecursive"
            
            Assert.Equal("Peer1", peers.Elements("DerivedRecursive").First().Element("BaseName")?.Value);

            // Round trip
            var restored = new DerivedRecursive();
            restored.ReadFromXml(xml);

            Assert.Equal("Base", restored.BaseName);
            Assert.Single(restored.Peers);
            Assert.Equal("Peer1", restored.Peers[0].BaseName);
        }
    }
}
