using Xunit;
using XmlSourceGenerator;
using System;
using System.Collections.Generic;
using System.Xml.Linq;
using XmlSourceGenerator.Abstractions;
using FluentAssertions;

namespace XmlSourceGenerator.Tests.Features
{
    public partial class ConfigurableOverridesTests
    {
        [XmlAutoGenerated]
        public partial class ConfigurableItem
        {
            [XmlElement("OriginalName")]
            public string Name { get; set; }

            [XmlElement("OriginalValue")]
            public int Value { get; set; }
        }

        [XmlAutoGenerated]
        public partial class PolymorphicContainer
        {
            [XmlElement("OriginalItem")]
            public object Item { get; set; }
        }

        [XmlAutoGenerated]
        public partial class DerivedA
        {
            public string PropA { get; set; }
        }

        [XmlAutoGenerated]
        public partial class DerivedB
        {
            public string PropB { get; set; }
        }

        [Fact]
        public void Override_RenamesElement_WhenPreferOptionsOverAttributesIsTrue()
        {
            var item = new ConfigurableItem { Name = "Test", Value = 42 };
            var options = new XmlSerializationOptions
            {
                PreferOptionsOverAttributes = true
            };
            
            // Configure override using PropertySettings
            options.PropertySettings.Add((typeof(ConfigurableItem), "Name"), new XmlPropertySettings 
            { 
                XmlName = "OverriddenName" 
            });

            // Verify setup
            var overrideVal = options.GetOverride(typeof(ConfigurableItem), "Name");
            overrideVal.Should().Be("OverriddenName");

            var xml = item.WriteToXml(options);

            // Should use overridden name
            xml.Element("OverriddenName")?.Value.Should().Be("Test");
            // Should NOT use original name
            xml.Element("OriginalName").Should().BeNull();
            
            // Value should remain unchanged (no override)
            xml.Element("OriginalValue")?.Value.Should().Be("42");
        }

        [Fact]
        public void Override_Ignored_WhenPreferOptionsOverAttributesIsFalse()
        {
            var item = new ConfigurableItem { Name = "Test" };
            var options = new XmlSerializationOptions
            {
                PreferOptionsOverAttributes = false // Default
            };
            
            options.PropertySettings.Add((typeof(ConfigurableItem), "Name"), new XmlPropertySettings 
            { 
                XmlName = "OverriddenName" 
            });

            var xml = item.WriteToXml(options);

            // Should use attribute name (default behavior)
            xml.Element("OriginalName")?.Value.Should().Be("Test");
            xml.Element("OverriddenName").Should().BeNull();
        }

        [Fact]
        public void Polymorphic_Override_Works_WhenPreferOptionsOverAttributesIsTrue()
        {
            var container = new PolymorphicContainer { Item = new DerivedA { PropA = "Alpha" } };
            var options = new XmlSerializationOptions
            {
                PreferOptionsOverAttributes = true
            };

            // Configure polymorphic mappings dynamically
            options.PropertySettings.Add((typeof(PolymorphicContainer), "Item"), new XmlPropertySettings
            {
                PolymorphicMappings = new List<(Type, string)>
                {
                    (typeof(DerivedA), "ItemA"),
                    (typeof(DerivedB), "ItemB")
                }
            });

            var xml = container.WriteToXml(options);

            // Should serialize as ItemA
            xml.Element("ItemA").Should().NotBeNull();
            xml.Element("ItemA").Element("PropA")?.Value.Should().Be("Alpha");
            
            // Should NOT use original name
            xml.Element("OriginalItem").Should().BeNull();
        }
        
        [Fact]
        public void Polymorphic_Read_Works_WithDynamicMappings()
        {
            var xml = XElement.Parse(@"
                <PolymorphicContainer>
                    <ItemB>
                        <PropB>Beta</PropB>
                    </ItemB>
                </PolymorphicContainer>");

            var options = new XmlSerializationOptions
            {
                PreferOptionsOverAttributes = true
            };

            options.PropertySettings.Add((typeof(PolymorphicContainer), "Item"), new XmlPropertySettings
            {
                PolymorphicMappings = new List<(Type, string)>
                {
                    (typeof(DerivedA), "ItemA"),
                    (typeof(DerivedB), "ItemB")
                }
            });

            var container = new PolymorphicContainer();
            container.ReadFromXml(xml, options);

            container.Item.Should().BeOfType<DerivedB>();
            ((DerivedB)container.Item).PropB.Should().Be("Beta");
        }
    }
}
