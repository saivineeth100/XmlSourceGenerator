using System.Collections.Generic;
using System.Xml.Linq;
using System.Xml.Serialization;
using Xunit;
using FluentAssertions;
using XmlSourceGenerator;

namespace XmlSourceGenerator.Tests.Integration
{
    #region Test Entities - Normal Hierarchy

    // Scenario 1: Override with XmlIgnore
    [XmlAutoGenerated]
    public partial class BaseWithElement
    {
        [XmlElement("CustomName")]
        public virtual string Name { get; set; }
    }

    [XmlAutoGenerated]
    public partial class DerivedIgnoresProperty : BaseWithElement
    {
        [XmlIgnore]
        public override string Name { get; set; }
    }

    // Scenario 2: Override element name
    [XmlAutoGenerated]
    public partial class BaseWithElementName
    {
        [XmlElement("OldName")]
        public virtual string Value { get; set; }
    }

    [XmlAutoGenerated]
    public partial class DerivedChangesElementName : BaseWithElementName
    {
        [XmlElement("NewName")]
        public override string Value { get; set; }
    }

    // Scenario 3: Change from element to attribute
    [XmlAutoGenerated]
    public partial class BaseSerializesAsElement
    {
        [XmlElement("ElementProp")]
        public virtual string Data { get; set; }
    }

    [XmlAutoGenerated]
    public partial class DerivedSerializesAsAttribute : BaseSerializesAsElement
    {
        [XmlAttribute("AttrProp")]
        public override string Data { get; set; }
    }

    // Scenario 4: Override without explicit attributes (should inherit)
    [XmlAutoGenerated]
    public partial class BaseWithAttributes
    {
        [XmlElement("BaseName")]
        public virtual string InheritedProp { get; set; }

        [XmlAttribute("baseId")]
        public virtual int InheritedAttr { get; set; }
    }

    [XmlAutoGenerated]
    public partial class DerivedInheritsAttributes : BaseWithAttributes
    {
        // No attributes - should inherit from base
        public override string InheritedProp { get; set; }
        public override int InheritedAttr { get; set; }
    }

    // Scenario 5: Using 'new' keyword (shadows base, no inheritance)
    [XmlAutoGenerated]
    public partial class BaseWithProperty
    {
        [XmlElement("BaseVersion")]
        public virtual string Shadowed { get; set; }
    }

    [XmlAutoGenerated]
    public partial class DerivedShadowsProperty : BaseWithProperty
    {
        // Using 'new' means no inheritance, needs explicit attributes
        public new string Shadowed { get; set; }
    }

    #endregion

    #region Test Entities - Nested Hierarchy

    [XmlAutoGenerated]
    public partial class GrandParent
    {
        [XmlElement("GrandParentName")]
        public virtual string Name { get; set; }
    }

    [XmlAutoGenerated]
    public partial class Parent : GrandParent
    {
        [XmlElement("ParentName")]
        public override string Name { get; set; }
    }

    [XmlAutoGenerated]
    public partial class Child : Parent
    {
        // Should inherit from immediate parent
        public override string Name { get; set; }
    }

    #endregion

    #region Test Entities - Collection Properties

    [XmlAutoGenerated]
    public partial class BaseWithCollection
    {
        [XmlArray("BaseItems")]
        [XmlArrayItem("BaseItem")]
        public virtual List<string> Items { get; set; }
    }

    [XmlAutoGenerated]
    public partial class DerivedChangesCollectionName : BaseWithCollection
    {
        [XmlArray("DerivedItems")]
        [XmlArrayItem("DerivedItem")]
        public override List<string> Items { get; set; }
    }

    [XmlAutoGenerated]
    public partial class DerivedInheritsCollectionAttributes : BaseWithCollection
    {
        // Should inherit XmlArray and XmlArrayItem from base
        public override List<string> Items { get; set; }
    }

    #endregion

    #region Test Entities - Edge Cases

    // Multiple properties with different overrides
    [XmlAutoGenerated]
    public partial class BaseMultipleProps
    {
        [XmlElement("Prop1")]
        public virtual string Property1 { get; set; }

        [XmlElement("Prop2")]
        public virtual string Property2 { get; set; }

        [XmlAttribute("attr3")]
        public virtual int Property3 { get; set; }
    }

    [XmlAutoGenerated]
    public partial class DerivedMixedOverrides : BaseMultipleProps
    {
        // Explicit override
        [XmlElement("NewProp1")]
        public override string Property1 { get; set; }

        // Inherit
        public override string Property2 { get; set; }

        // Ignore
        [XmlIgnore]
        public override int Property3 { get; set; }
    }

    #endregion

    public class PropertyOverrideTests
    {
        #region Scenario 1: XmlIgnore Override

        [Fact]
        public void Override_WithXmlIgnore_ShouldNotSerialize()
        {
            var entity = new DerivedIgnoresProperty
            {
                Name = "ShouldNotAppear"
            };

            var xml = entity.WriteToXml();

            // Property should not be in XML
            xml.Element("CustomName").Should().BeNull();
            xml.Element("Name").Should().BeNull();
        }

        [Fact]
        public void Override_WithXmlIgnore_ShouldNotDeserialize()
        {
            var xml = new XElement("DerivedIgnoresProperty",
                new XElement("CustomName", "IgnoredValue"));

            var entity = new DerivedIgnoresProperty();
            entity.ReadFromXml(xml);

            // Property should remain null/default
            entity.Name.Should().BeNull();
        }

        #endregion

        #region Scenario 2: Change Element Name

        [Fact]
        public void Override_ChangeElementName_ShouldUseNewName()
        {
            var entity = new DerivedChangesElementName
            {
                Value = "TestValue"
            };

            var xml = entity.WriteToXml();

            xml.Element("NewName")?.Value.Should().Be("TestValue");
            xml.Element("OldName").Should().BeNull();
        }

        [Fact]
        public void Override_ChangeElementName_ShouldDeserializeFromNewName()
        {
            var xml = new XElement("DerivedChangesElementName",
                new XElement("NewName", "TestValue"));

            var entity = new DerivedChangesElementName();
            entity.ReadFromXml(xml);

            entity.Value.Should().Be("TestValue");
        }

        #endregion

        #region Scenario 3: Element to Attribute

        [Fact]
        public void Override_ElementToAttribute_ShouldSerializeAsAttribute()
        {
            var entity = new DerivedSerializesAsAttribute
            {
                Data = "AttributeValue"
            };

            var xml = entity.WriteToXml();

            xml.Attribute("AttrProp")?.Value.Should().Be("AttributeValue");
            xml.Element("ElementProp").Should().BeNull();
        }

        [Fact]
        public void Override_ElementToAttribute_ShouldDeserializeFromAttribute()
        {
            var xml = new XElement("DerivedSerializesAsAttribute",
                new XAttribute("AttrProp", "AttributeValue"));

            var entity = new DerivedSerializesAsAttribute();
            entity.ReadFromXml(xml);

            entity.Data.Should().Be("AttributeValue");
        }

        #endregion

        #region Scenario 4: Attribute Inheritance

        [Fact]
        public void Override_WithoutAttributes_ShouldInheritFromBase()
        {
            var entity = new DerivedInheritsAttributes
            {
                InheritedProp = "ElementValue",
                InheritedAttr = 42
            };

            var xml = entity.WriteToXml();

            // Should use base element name
            xml.Element("BaseName")?.Value.Should().Be("ElementValue");
            // Should use base attribute name
            xml.Attribute("baseId")?.Value.Should().Be("42");
        }

        [Fact]
        public void Override_WithoutAttributes_ShouldDeserializeUsingInheritedNames()
        {
            var xml = new XElement("DerivedInheritsAttributes",
                new XAttribute("baseId", 99),
                new XElement("BaseName", "InheritedValue"));

            var entity = new DerivedInheritsAttributes();
            entity.ReadFromXml(xml);

            entity.Should().BeEquivalentTo(new DerivedInheritsAttributes
            {
                InheritedProp = "InheritedValue",
                InheritedAttr = 99
            });
        }

        #endregion

        #region Scenario 5: 'new' Keyword (Shadow, No Inheritance)

        [Fact]
        public void Shadow_WithNew_ShouldNotInherit()
        {
            var entity = new DerivedShadowsProperty
            {
                Shadowed = "ShadowedValue"
            };

            var xml = entity.WriteToXml();

            // Should use property name (no attribute), not base "BaseVersion"
            xml.Element("Shadowed")?.Value.Should().Be("ShadowedValue");
            xml.Element("BaseVersion").Should().BeNull();
        }

        #endregion

        #region Scenario 6: Nested Hierarchy

        [Fact]
        public void NestedOverride_ShouldInheritFromImmediateParent()
        {
            var entity = new Child
            {
                Name = "ChildValue"
            };

            var xml = entity.WriteToXml();

            // Should use Parent's element name, not GrandParent's
            xml.Element("ParentName")?.Value.Should().Be("ChildValue");
            xml.Element("GrandParentName").Should().BeNull();
        }

        [Fact]
        public void NestedOverride_ShouldDeserializeUsingParentName()
        {
            var xml = new XElement("Child",
                new XElement("ParentName", "InheritedValue"));

            var entity = new Child();
            entity.ReadFromXml(xml);

            entity.Name.Should().Be("InheritedValue");
        }

        #endregion

        #region Scenario 7: Collection Properties

        [Fact]
        public void CollectionOverride_WithNewAttributes_ShouldUseNewNames()
        {
            var entity = new DerivedChangesCollectionName
            {
                Items = new List<string> { "Item1", "Item2" }
            };

            var xml = entity.WriteToXml();

            var arrayElement = xml.Element("DerivedItems");
            arrayElement.Should().NotBeNull();
            arrayElement.Elements("DerivedItem").Should().HaveCount(2);
        }

        [Fact]
        public void CollectionOverride_WithoutAttributes_ShouldInheritNames()
        {
            var entity = new DerivedInheritsCollectionAttributes
            {
                Items = new List<string> { "Item1", "Item2" }
            };

            var xml = entity.WriteToXml();

            // Should use base array and item names
            var arrayElement = xml.Element("BaseItems");
            arrayElement.Should().NotBeNull();
            arrayElement.Elements("BaseItem").Should().HaveCount(2);
        }

        #endregion

        #region Scenario 8: Mixed Overrides

        [Fact]
        public void MultipleProperties_WithMixedOverrides_ShouldHandleEach()
        {
            var entity = new DerivedMixedOverrides
            {
                Property1 = "Value1",
                Property2 = "Value2",
                Property3 = 42
            };

            var xml = entity.WriteToXml();

            // Explicit override
            xml.Element("NewProp1")?.Value.Should().Be("Value1");
            xml.Element("Prop1").Should().BeNull();

            // Inherited
            xml.Element("Prop2")?.Value.Should().Be("Value2");

            // Ignored
            xml.Attribute("attr3").Should().BeNull();
        }

        #endregion

        #region Edge Cases

        [Fact]
        public void RoundTrip_WithOverrides_ShouldMaintainData()
        {
            var original = new DerivedInheritsAttributes
            {
                InheritedProp = "TestElement",
                InheritedAttr = 123
            };

            var xml = original.WriteToXml();
            var deserialized = new DerivedInheritsAttributes();
            deserialized.ReadFromXml(xml);

            deserialized.Should().BeEquivalentTo(original);
        }

        [Fact]
        public void ComplexHierarchy_WithMultipleOverrides_ShouldWork()
        {
            var entity = new Child
            {
                Name = "ComplexTest"
            };

            var xml = entity.WriteToXml();
            var deserialized = new Child();
            deserialized.ReadFromXml(xml);

            deserialized.Name.Should().Be("ComplexTest");
        }

        #endregion
    }
}
