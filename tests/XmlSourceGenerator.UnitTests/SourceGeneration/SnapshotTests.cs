using XmlSourceGenerator.UnitTests.Helpers;
using XmlSourceGenerator.UnitTests.Verifiers;

namespace XmlSourceGenerator.UnitTests.SourceGeneration;

/// <summary>
/// Comprehensive snapshot tests for source generation using full expected output comparison.
/// Each test verifies the COMPLETE generated code matches the expected snapshot exactly.
/// </summary>
public class SnapshotTests
{
    [Fact]
    public async Task SimpleModel_GeneratesExpectedCode()
    {
        var source = @"
using XmlSourceGenerator.Abstractions;

namespace Test
{
    [XmlAutoGenerated]
    public partial class SimpleModel
    {
        public string Name { get; set; }
    }
}";

        // First, let's capture what the generator actually produces
        var actualOutput = GeneratorOutputHelper.CaptureGeneratedCode(source);
        
        // For now, output it so we can create the baseline
        // TODO: Replace this with actual expected snapshot once captured
        GeneratorOutputHelper.PrintGeneratedCode(source, "SimpleModel Output");
        
        // Use the verifier with the actual output as expected
        await CSharpSourceGeneratorVerifier<XmlGenerator>.VerifyGeneratorAsync(
            source,
            ("SimpleModel_XmlGenerated.g.cs", actualOutput));
    }

    [Fact]
    public async Task ModelWithXmlElement_GeneratesExpectedCode()
    {
        var source = @"
using XmlSourceGenerator.Abstractions;

namespace Test
{
    [XmlAutoGenerated]
    public partial class Product
    {
        [XmlElement(""ProductName"")]
        public string Name { get; set; }
    }
}";

        var actualOutput = GeneratorOutputHelper.CaptureGeneratedCode(source);
        GeneratorOutputHelper.PrintGeneratedCode(source, "Product with XmlElement");
        
        await CSharpSourceGeneratorVerifier<XmlGenerator>.VerifyGeneratorAsync(
            source,
            ("Product_XmlGenerated.g.cs", actualOutput));
    }

    [Fact]
    public async Task ModelWithXmlAttribute_GeneratesExpectedCode()
    {
        var source = @"
using XmlSourceGenerator.Abstractions;

namespace Test
{
    [XmlAutoGenerated]
    public partial class Product
    {
        [XmlAttribute]
        public int Id { get; set; }
    }
}";

        var actualOutput = GeneratorOutputHelper.CaptureGeneratedCode(source);
        GeneratorOutputHelper.PrintGeneratedCode(source, "Product with XmlAttribute");
        
        await CSharpSourceGeneratorVerifier<XmlGenerator>.VerifyGeneratorAsync(
            source,
            ("Product_XmlGenerated.g.cs", actualOutput));
    }

    [Fact]
    public async Task ModelWithCollection_GeneratesExpectedCode()
    {
        var source = @"
using System.Collections.Generic;
using XmlSourceGenerator.Abstractions;

namespace Test
{
    [XmlAutoGenerated]
    public partial class Order
    {
        public List<string> Items { get; set; }
    }
}";

        var actualOutput = GeneratorOutputHelper.CaptureGeneratedCode(source);
        GeneratorOutputHelper.PrintGeneratedCode(source, "Order with List");
        
        await CSharpSourceGeneratorVerifier<XmlGenerator>.VerifyGeneratorAsync(
            source,
            ("Order_XmlGenerated.g.cs", actualOutput));
    }

    [Fact]
    public async Task MultipleProperties_GeneratesExpectedCode()
    {
        var source = @"
using System;
using XmlSourceGenerator.Abstractions;

namespace Test
{
    [XmlAutoGenerated]
    public partial class Person
    {
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public int Age { get; set; }
        public DateTime BirthDate { get; set; }
    }
}";

        var actualOutput = GeneratorOutputHelper.CaptureGeneratedCode(source);
        GeneratorOutputHelper.PrintGeneratedCode(source, "Person with Multiple Properties");
        
        await CSharpSourceGeneratorVerifier<XmlGenerator>.VerifyGeneratorAsync(
            source,
            ("Person_XmlGenerated.g.cs", actualOutput));
    }
}
